/* Generated By:JavaCC: Do not edit this line. XPathParser.java */
/*========================================================================*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License.
 * 
 * You may obtain a copy of the License at http://www.mozilla.org/MPL/ 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and
 * limitations under the License. 
 * 
 * The Original Code is all this file. 
 * 
 * The Initial Developer of the Original Code is
 * Aleksei Valikov, Forchungszentrum Informatik (valikov@fzi.de).
 * 
 * Portions created by Ingo Macherius, Gerald Huck <{macherius, huck}@gmd.de>
 * are Copyright (C) 1999 GMD.
 * All Rights Reserved. 
 * 
 * Contributor(s): none.
 *========================================================================*/

package de.fzi.XPath.Parser;

import java.io.IOException;

import de.fzi.XPath. *;

public class XPathParser implements XPathParserConstants {

  final public String NCName() throws ParseException {
    trace_call("NCName");
    try {
      Token t;
      switch (jj_nt.kind) {
      case NCName:
        t = jj_consume_token(NCName);
        {if (true) return t.image;}
        break;
      case ID:
        t = jj_consume_token(ID);
        {if (true) return t.image;}
        break;
      case OR:
        t = jj_consume_token(OR);
        {if (true) return t.image;}
        break;
      case AND:
        t = jj_consume_token(AND);
        {if (true) return t.image;}
        break;
      case MOD:
        t = jj_consume_token(MOD);
        {if (true) return t.image;}
        break;
      case DIV:
        t = jj_consume_token(DIV);
        {if (true) return t.image;}
        break;
      case KEY:
        t = jj_consume_token(KEY);
        {if (true) return t.image;}
        break;
      case NODE:
        t = jj_consume_token(NODE);
        {if (true) return t.image;}
        break;
      case TEXT:
        t = jj_consume_token(TEXT);
        {if (true) return t.image;}
        break;
      case COMMENT:
        t = jj_consume_token(COMMENT);
        {if (true) return t.image;}
        break;
      case PI:
        t = jj_consume_token(PI);
        {if (true) return t.image;}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NCName");
    }
  }

  final public String NCName_Without_NodeType() throws ParseException {
    trace_call("NCName_Without_NodeType");
    try {
        Token t;
      switch (jj_nt.kind) {
      case NCName:
        t = jj_consume_token(NCName);
        {if (true) return t.image;}
        break;
      case ID:
        t = jj_consume_token(ID);
        {if (true) return t.image;}
        break;
      case OR:
        t = jj_consume_token(OR);
        {if (true) return t.image;}
        break;
      case AND:
        t = jj_consume_token(AND);
        {if (true) return t.image;}
        break;
      case MOD:
        t = jj_consume_token(MOD);
        {if (true) return t.image;}
        break;
      case DIV:
        t = jj_consume_token(DIV);
        {if (true) return t.image;}
        break;
      case KEY:
        t = jj_consume_token(KEY);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NCName_Without_NodeType");
    }
  }

  final public String QName() throws ParseException {
    trace_call("QName");
    try {
      String prefix;
      String name;
      prefix = NCName();
      switch (jj_nt.kind) {
      case 35:
        jj_consume_token(35);
        name = NCName();
        {if (true) return prefix + ":" + name;}
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
        {if (true) return prefix;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("QName");
    }
  }

  final public String QName_Without_NodeType() throws ParseException {
    trace_call("QName_Without_NodeType");
    try {
      String prefix;
      String name;
      prefix = NCName_Without_NodeType();
      switch (jj_nt.kind) {
      case 35:
        jj_consume_token(35);
        name = NCName_Without_NodeType();
       {if (true) return prefix + ":" + name;}
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
       {if (true) return prefix;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("QName_Without_NodeType");
    }
  }

/* ################################################################################### */
/* XSLT Patterns (http://www.w3.org/1999/08/WD-xslt-19990813)                          */
/* ################################################################################### */

/* [XSLT1] Pattern ::= LocationPathPattern | Pattern '|' LocationPathPattern  */
  final public void Pattern() throws ParseException {
    trace_call("Pattern");
    try {
      LocationPathPattern();
      label_1:
      while (true) {
        switch (jj_nt.kind) {
        case UNION:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_1;
        }
        jj_consume_token(UNION);
        LocationPathPattern();
      }
      jj_consume_token(0);
    } finally {
      trace_return("Pattern");
    }
  }

/* [XSLT2] LocationPathPattern ::=
   '/' RelativePathPattern? | IdKeyPattern (('/' | '//' RelativePathPattern)? | '//'? RelativePathPattern
*/
  final public void LocationPathPattern() throws ParseException {
    trace_call("LocationPathPattern");
    try {
      switch (jj_nt.kind) {
      case SLASH:
        jj_consume_token(SLASH);
        switch (jj_nt.kind) {
        case ID:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case KEY:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case NCName:
        case 39:
        case 44:
          RelativePathPattern();
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
        break;
      case SLASHSLASH:
      case ID:
      case OR:
      case AND:
      case MOD:
      case DIV:
      case KEY:
      case NODE:
      case TEXT:
      case COMMENT:
      case PI:
      case NCName:
      case 39:
      case 44:
        if (jj_2_1(2147483647)) {
          IdKeyPattern();
          switch (jj_nt.kind) {
          case SLASH:
          case SLASHSLASH:
            switch (jj_nt.kind) {
            case SLASH:
              jj_consume_token(SLASH);
              break;
            case SLASHSLASH:
              jj_consume_token(SLASHSLASH);
              break;
            default:
              jj_la1[6] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            RelativePathPattern();
            break;
          default:
            jj_la1[7] = jj_gen;
            ;
          }
        } else {
          switch (jj_nt.kind) {
          case SLASHSLASH:
          case ID:
          case OR:
          case AND:
          case MOD:
          case DIV:
          case KEY:
          case NODE:
          case TEXT:
          case COMMENT:
          case PI:
          case NCName:
          case 39:
          case 44:
            switch (jj_nt.kind) {
            case SLASHSLASH:
              jj_consume_token(SLASHSLASH);
              break;
            default:
              jj_la1[8] = jj_gen;
              ;
            }
            RelativePathPattern();
            break;
          default:
            jj_la1[9] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("LocationPathPattern");
    }
  }

/* [XSLT3] IdKeyPattern    ::=    'id' '(' Literal ')' | 'key' '(' Literal ',' Literal ')'  */
  final public void IdKeyPattern() throws ParseException {
    trace_call("IdKeyPattern");
    try {
      switch (jj_nt.kind) {
      case ID:
        jj_consume_token(ID);
        jj_consume_token(36);
        jj_consume_token(Literal);
        jj_consume_token(37);
        break;
      case KEY:
        jj_consume_token(KEY);
        jj_consume_token(36);
        jj_consume_token(Literal);
        jj_consume_token(38);
        jj_consume_token(Literal);
        jj_consume_token(37);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("IdKeyPattern");
    }
  }

/* [XSLT4] RelativePathPattern    ::=    StepPattern | RelativePathPattern '/' StepPattern 
   						| RelativePathPattern '//' StepPattern  
*/
  final public void RelativePathPattern() throws ParseException {
    trace_call("RelativePathPattern");
    try {
      StepPattern();
      label_2:
      while (true) {
        switch (jj_nt.kind) {
        case SLASH:
        case SLASHSLASH:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_2;
        }
        switch (jj_nt.kind) {
        case SLASH:
          jj_consume_token(SLASH);
          break;
        case SLASHSLASH:
          jj_consume_token(SLASHSLASH);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        StepPattern();
      }
    } finally {
      trace_return("RelativePathPattern");
    }
  }

/* [XSLT5]    StepPattern    ::=    AbbreviatedAxisSpecifier NodeTest Predicate*   */
  final public void StepPattern() throws ParseException {
    trace_call("StepPattern");
    try {
      AbbreviatedAxisSpecifier();
      NodeTest();
      label_3:
      while (true) {
        switch (jj_nt.kind) {
        case 42:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_3;
        }
        Predicate();
      }
    } finally {
      trace_return("StepPattern");
    }
  }

/* ################################################################################### */
/* XPath (http://www.w3.org/1999/08/WD-xpath-19990813 )                                */
/* ################################################################################### */


/*------------------*/
/* 2 Location Paths */
/*------------------*/
  
  public void e2(){};
  
  final public Expr XPath() throws ParseException, IOException {
	  trace_call("XPath");
	  try {
		  Expr expr;
		  expr = Expr(); // can generate most the constraints!
		  //       {if (true) return expr;}
		  if (true)
		  {
			  jj_input_stream.backup(1); 
			  char last = jj_input_stream.readChar();  
			  if (last == 'b') {
				  e2();
			  }
			  return expr;
		  }
		  jj_consume_token(0);
		  throw new Error("Missing return statement in function");
	  } finally {
		  trace_return("XPath");
	  }
  }
//  final public void XPath2() throws ParseException, IOException {
//			  jj_input_stream.backup(1); 
//			  char last = jj_input_stream.readChar();  
//			  //		  System.out.println("last");  
//			  if (last == 'b') {
//				  e2();
//				  System.out.println("violation2");
//			  }
//  }

/* [1] LocationPath ::= RelativeLocationPath | AbsoluteLocationPath  */
  final public LocationPath LocationPath() throws ParseException {
    trace_call("LocationPath");
    try {
      LocationPath lp;
      LocationPath rlp;
      if (jj_2_2(2)) {
        jj_consume_token(SLASH);
      {if (true) return new LocationPath(true);}
      } else {
        switch (jj_nt.kind) {
        case SLASH:
          jj_consume_token(SLASH);
          lp = RelativeLocationPath();
          lp.setRelative(false);
          {if (true) return lp;}
          break;
        case ID:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case KEY:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case AxisName:
        case NCName:
        case 39:
        case 40:
        case 41:
        case 44:
          lp = RelativeLocationPath();
      {if (true) return lp;}
          break;
        case SLASHSLASH:
          jj_consume_token(SLASHSLASH);
          rlp = RelativeLocationPath();
          lp = new LocationPath(true);
          lp.addStep(new Step(Axis.DESCENDANT_OR_SELF, new NodeType("node")));
          lp.addLocationPath(rlp);
          {if (true) return lp;}
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LocationPath");
    }
  }

/* [2] AbsoluteLocationPath ::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath  */
/*LocationPath AbsoluteLocationPath() :
{LocationPath lp;
 LocationPath rlp;
}
{
	
		lp=AbbreviatedAbsoluteLocationPath()
{return lp;}
	|	<SLASH>
{lp = new LocationPath(true);}
( LOOKAHEAD
  ( RelativeLocationPath() )
rlp=RelativeLocationPath()
{lp.addLocationPath(rlp);}
)?  
{return lp;}
}             */
/* [3] RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | AbbreviatedRelativeLocationPath */
  final public LocationPath RelativeLocationPath() throws ParseException {
    trace_call("RelativeLocationPath");
    try {
 LocationPath lp = new LocationPath();
 Step step;
 LocationPath rlp;
      step = Step();
 lp.addStep(step);
      if (jj_2_3(2147483647)) {
        switch (jj_nt.kind) {
        case SLASH:
          jj_consume_token(SLASH);
          break;
        case SLASHSLASH:
          jj_consume_token(SLASHSLASH);
 lp.addStep(new Step(Axis.DESCENDANT_OR_SELF, new NodeType("node")));
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        rlp = RelativeLocationPath();
 lp.addLocationPath(rlp);
      } else {
        ;
      }
 {if (true) return lp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RelativeLocationPath");
    }
  }

/*--------------------*/
/* 2.1 Location Steps */
/*--------------------*/

/* [4] Step ::= AxisSpecifier NodeTest Predicate*   | AbbreviatedStep  */
  final public Step Step() throws ParseException {
    trace_call("Step");
    try {
 Step step;
 int axis;
 NodeTest nt;
 Expr predicate;
 Token t;
      switch (jj_nt.kind) {
      case ID:
      case OR:
      case AND:
      case MOD:
      case DIV:
      case KEY:
      case NODE:
      case TEXT:
      case COMMENT:
      case PI:
      case AxisName:
      case NCName:
      case 39:
      case 44:
        switch (jj_nt.kind) {
        case ID:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case KEY:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case NCName:
        case 44:
          nt = NodeTest();
                 step = new Step(Axis.CHILD, nt);
          break;
        case AxisName:
          t = jj_consume_token(AxisName);
          nt = NodeTest();
                 step = new Step(Axis.getAxis(t.image), nt);
          break;
        case 39:
          jj_consume_token(39);
          nt = NodeTest();
                 step = new Step(Axis.ATTRIBUTE, nt);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_4:
        while (true) {
          switch (jj_nt.kind) {
          case 42:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_4;
          }
          predicate = Predicate();
                                         step.addPredicate(predicate);
        }
                 {if (true) return step;}
        break;
      case 40:
        jj_consume_token(40);
 {if (true) return new Step(Axis.SELF, new NodeType("node"));}
        break;
      case 41:
        jj_consume_token(41);
 {if (true) return new Step(Axis.PARENT, new NodeType("node"));}
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Step");
    }
  }

/* [5] AxisSpecifier ::=    AxisName '::' | AbbreviatedAxisSpecifier  */
/*
int AxisSpecifier() :
{int axis;}
{
		axis=AxisName()
{return axis;}
           
	|	axis=AbbreviatedAxisSpecifier()
{return axis;}
}
*/
/*----------*/
/* 2.2 Axes */
/*----------*/

/* [6] AxisName ::= 'ancestor' | 'ancestor-or-self' | 'attribute'  | 'child' | 'descendant'  
					| 'descendant-or-self' | 'following' | 'following-sibling' | 'namespace'  
   					| 'parent' | 'preceding' | 'preceding-sibling' | 'self'
*/
/*
int AxisName() :
{
 Token t;}
{
	t=<AxisName>
{return Axis.getAxis(t.image);}
}
*/
/*----------------*/
/* 2.3 Node Tests */
/*----------------*/

/* [7] NodeTest ::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')' */
  final public NodeTest NodeTest() throws ParseException {
    trace_call("NodeTest");
    try {
 NodeTest nt;
 Token pi;
 Token t;
      if (jj_2_4(2147483647)) {
        nt = NodeType();
        jj_consume_token(36);
        jj_consume_token(37);
 {if (true) return nt;}
      } else if (jj_2_5(2147483647)) {
        pi = jj_consume_token(PI);
        jj_consume_token(36);
        t = jj_consume_token(Literal);
        jj_consume_token(37);
 {if (true) return new NodeType(pi.image,  t.image);}
      } else {
        switch (jj_nt.kind) {
        case ID:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case KEY:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case NCName:
        case 44:
          nt = NameTest();
 {if (true) return nt;}
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NodeTest");
    }
  }

/*----------------*/
/* 2.4 Predicates */
/*----------------*/

/* [8] Predicate ::= '[' PredicateExpr ']'  */
  final public Expr Predicate() throws ParseException {
    trace_call("Predicate");
    try {
 Expr expr;
      jj_consume_token(42);
      expr = Expr();
      jj_consume_token(43);
 {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Predicate");
    }
  }

/* [9] PredicateExpr ::=  Expr  */
/*
Expr PredicateExpr() :
{Expr expr;}
{
		expr=Expr()
{return expr;}
}
*/
/*------------------------*/
/* 2.5 Abbreviated Syntax */
/*------------------------*/
/* [10]    AbbreviatedAbsoluteLocationPath    ::=    '//' RelativeLocationPath  */
/*LocationPath AbbreviatedAbsoluteLocationPath() :
{LocationPath lp;
 LocationPath rlp;

}
{
<SLASHSLASH> rlp=RelativeLocationPath()
{
lp=new LocationPath(true);
lp.addStep(new Step(Axis.DESCENDANT_OR_SELF, new NodeType("node")));
lp.addLocationPath(rlp);
return lp;
}
}
*/
/* [11]    AbbreviatedRelativeLocationPath    ::=    RelativeLocationPath '//' Step  */
/*LocationPath AbbreviatedRelativeLocationPath() :
{LocationPath lp;
Step step;}
{
lp=RelativeLocationPath() <SLASHSLASH> step=Step()

{lp.addStep(new Step(Axis.DESCENDANT_OR_SELF, new NodeType("node")));
lp.addStep(step);
return lp;}
}
*/
/* [12]    AbbreviatedStep    ::=    '.'  | '..'  */
/*
Step AbbreviatedStep() :
{}
{
	"." 
{return new Step(Axis.SELF, new NodeType("node"));}
 | ".."
{return new Step(Axis.PARENT, new NodeType("node"));}
}
*/
/* [13]    AbbreviatedAxisSpecifier    ::=    '@'? */
  final public int AbbreviatedAxisSpecifier() throws ParseException {
    trace_call("AbbreviatedAxisSpecifier");
    try {
      switch (jj_nt.kind) {
      case 39:
        jj_consume_token(39);
               {if (true) return Axis.ATTRIBUTE;}
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
 {if (true) return Axis.CHILD;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AbbreviatedAxisSpecifier");
    }
  }

/*---------------*/
/* 3 Expressions */
/*---------------*/

/*------------*/
/* 3.1 Basics */
/*------------*/

/*
The effect of the grammar is that the order of precedence is (lowest precedence first): 
	or 
	and 
	=, != 
	<=, <, >=, > 
and all operators are left associative.
For example, 3 > 2 > 1 is equivalent to (3 > 2) > 1, which evaluates to false. 
*/

/* [14] Expr ::= OrExpr */
  final public Expr Expr() throws ParseException {
    trace_call("Expr");
    try {
 Expr expr;
      expr = OrExpr();
 {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expr");
    }
  }

/* [15] PrimaryExpr ::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall */
  final public Expr PrimaryExpr() throws ParseException {
    trace_call("PrimaryExpr");
    try {
 Expr expr;
 Token t;
      switch (jj_nt.kind) {
      case VARIABLE:
        expr = VariableReference();
 {if (true) return expr;}
        break;
      case 36:
        jj_consume_token(36);
        expr = Expr();
        jj_consume_token(37);
 {if (true) return expr;}
        break;
      case Literal:
        t = jj_consume_token(Literal);
 {if (true) return new Literal(t.image);}
        break;
      case Number:
        t = jj_consume_token(Number);
 {if (true) return new de.fzi.XPath.Number(t.image);}
        break;
      case ID:
      case OR:
      case AND:
      case MOD:
      case DIV:
      case KEY:
      case NCName:
        expr = FunctionCall();
 {if (true) return expr;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PrimaryExpr");
    }
  }

/*--------------------*/
/* 3.2 Function Calls */
/*--------------------*/

/* [16]    FunctionCall    ::=    FunctionName '(' ( Argument ( ',' Argument)*)? ')'  */
  final public Expr FunctionCall() throws ParseException {
    trace_call("FunctionCall");
    try {
String name;
FunctionCall fc;
Expr arg;
      name = FunctionName();
 fc=new FunctionCall(name);
      jj_consume_token(36);
      switch (jj_nt.kind) {
      case SLASH:
      case SLASHSLASH:
      case MINUS:
      case VARIABLE:
      case Literal:
      case Number:
      case ID:
      case OR:
      case AND:
      case MOD:
      case DIV:
      case KEY:
      case NODE:
      case TEXT:
      case COMMENT:
      case PI:
      case AxisName:
      case NCName:
      case 36:
      case 39:
      case 40:
      case 41:
      case 44:
        arg = Argument();
                      fc.addArgument(arg);
        label_5:
        while (true) {
          switch (jj_nt.kind) {
          case 38:
            ;
            break;
          default:
            jj_la1[23] = jj_gen;
            break label_5;
          }
          jj_consume_token(38);
          arg = Argument();
                         fc.addArgument(arg);
        }
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      jj_consume_token(37);
 {if (true) return fc;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionCall");
    }
  }

/* [17]    Argument    ::=    Expr */
  final public Expr Argument() throws ParseException {
    trace_call("Argument");
    try {
 Expr expr;
      expr = Expr();
 {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Argument");
    }
  }

/*---------------*/
/* 3.3 Node-sets */
/*---------------*/

/* [18] UnionExpr    ::=    PathExpr | UnionExpr '|' PathExpr */
  final public Expr UnionExpr() throws ParseException {
    trace_call("UnionExpr");
    try {
 Expr expr;
 Expr operand;
 UnionExpr superexpr = new UnionExpr();
      expr = PathExpr();
 operand=expr;
superexpr.addExpr(operand, Expr.NOP_OP);
      label_6:
      while (true) {
        switch (jj_nt.kind) {
        case UNION:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_6;
        }
        jj_consume_token(UNION);
        operand = PathExpr();
 superexpr.addExpr(operand);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnionExpr");
    }
  }

/* [19] PathExpr ::= LocationPath | FilterExpr | FilterExpr '/' RelativeLocationPath | FilterExpr '//' RelativeLocationPath  */
  final public Expr PathExpr() throws ParseException {
    trace_call("PathExpr");
    try {
 FilterExpr fe;
LocationPath lp;
LocationPath rlp;
LocationPath slp;
      if (jj_2_6(2147483647)) {
        fe = FilterExpr();
        switch (jj_nt.kind) {
        case SLASH:
        case SLASHSLASH:
          switch (jj_nt.kind) {
          case SLASH:
            jj_consume_token(SLASH);
            break;
          case SLASHSLASH:
            jj_consume_token(SLASHSLASH);
 slp = new LocationPath();
slp.addStep(new Step(Axis.DESCENDANT_OR_SELF, new NodeType("node")));
fe.setLocationPath(slp);
            break;
          default:
            jj_la1[26] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          rlp = RelativeLocationPath();
 if (fe.getLocationPath()==null) fe.setLocationPath(rlp);
else fe.getLocationPath().addLocationPath(rlp);
          break;
        default:
          jj_la1[27] = jj_gen;
          ;
        }
 {if (true) return fe;}
      } else {
        switch (jj_nt.kind) {
        case SLASH:
        case SLASHSLASH:
        case ID:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case KEY:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case AxisName:
        case NCName:
        case 39:
        case 40:
        case 41:
        case 44:
          lp = LocationPath();
 {if (true) return lp;}
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PathExpr");
    }
  }

/* [20]    FilterExpr    ::=    PrimaryExpr    | FilterExpr Predicate */
  final public FilterExpr FilterExpr() throws ParseException {
    trace_call("FilterExpr");
    try {
 Expr expr;
FilterExpr fe;
Expr predicate;
      expr = PrimaryExpr();
 fe=new FilterExpr(expr);
      label_7:
      while (true) {
        switch (jj_nt.kind) {
        case 42:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_7;
        }
        predicate = Predicate();
 fe.addPredicate(predicate);
      }
 {if (true) return fe;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FilterExpr");
    }
  }

/*--------------*/
/* 3.4 Booleans */
/*--------------*/

/* [21] OrExpr    ::=    AndExpr | OrExpr 'or' AndExpr */
  final public Expr OrExpr() throws ParseException {
    trace_call("OrExpr");
    try {
 Expr expr;
 OrExpr superexpr = new OrExpr();
      expr = AndExpr();
 Expr operand=expr;
 superexpr.addExpr(operand, Expr.NOP_OP);
      label_8:
      while (true) {
        switch (jj_nt.kind) {
        case OR:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_8;
        }
        jj_consume_token(OR);
        operand = AndExpr();
 superexpr.addExpr(operand);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OrExpr");
    }
  }

/* [22] AndExpr    ::=    EqualityExpr  | AndExpr 'and' EqualityExpr  */
  final public Expr AndExpr() throws ParseException {
    trace_call("AndExpr");
    try {
 Expr expr;
 AndExpr superexpr = new AndExpr();
      expr = EqualityExpr();
 Expr operand=expr;
 superexpr.addExpr(operand, Expr.NOP_OP);
      label_9:
      while (true) {
        switch (jj_nt.kind) {
        case AND:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_9;
        }
        jj_consume_token(AND);
        operand = EqualityExpr();
 superexpr.addExpr(operand);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AndExpr");
    }
  }

/* [23] EqualityExpr    ::=    RelationalExpr | EqualityExpr '=' RelationalExpr | EqualityExpr '!=' RelationalExpr */
  final public Expr EqualityExpr() throws ParseException {
    trace_call("EqualityExpr");
    try {
 Expr expr;
 EqualityExpr superexpr = new EqualityExpr();
 int operator = Expr.NOP_OP;
      expr = RelationalExpr();
 Expr operand=expr;
 superexpr.addExpr(operand, operator);
      label_10:
      while (true) {
        switch (jj_nt.kind) {
        case EQ:
        case NEQ:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_10;
        }
        switch (jj_nt.kind) {
        case EQ:
          jj_consume_token(EQ);
 operator=Expr.EQ_OP;
          break;
        case NEQ:
          jj_consume_token(NEQ);
 operator=Expr.NEQ_OP;
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        operand = RelationalExpr();
 superexpr.addExpr(operand, operator);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EqualityExpr");
    }
  }

/* [24] RelationalExpr    ::=    AdditiveExpr | RelationalExpr '<' AdditiveExpr | RelationalExpr '>' AdditiveExpr  
					   | RelationalExpr '<=' AdditiveExpr  | RelationalExpr '>=' AdditiveExpr */
  final public Expr RelationalExpr() throws ParseException {
    trace_call("RelationalExpr");
    try {
 Expr expr;
 RelationalExpr superexpr = new RelationalExpr();
 int operator = Expr.NOP_OP;
      expr = AdditiveExpr();
 Expr operand=expr;
 superexpr.addExpr(operand, operator);
      label_11:
      while (true) {
        switch (jj_nt.kind) {
        case LT:
        case LTE:
        case GT:
        case GTE:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_11;
        }
        switch (jj_nt.kind) {
        case LT:
          jj_consume_token(LT);
 operator=Expr.LT_OP;
          break;
        case GT:
          jj_consume_token(GT);
 operator=Expr.GT_OP;
          break;
        case LTE:
          jj_consume_token(LTE);
 operator=Expr.LTE_OP;
          break;
        case GTE:
          jj_consume_token(GTE);
 operator=Expr.GTE_OP;
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        operand = AdditiveExpr();
 superexpr.addExpr(operand, operator);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RelationalExpr");
    }
  }

/*-------------*/
/* 3.5 Numbers */
/*-------------*/

/* [25] AdditiveExpr ::= MultiplicativeExpr  | AdditiveExpr '+' MultiplicativeExpr  | AdditiveExpr '-' MultiplicativeExpr  */
  final public Expr AdditiveExpr() throws ParseException {
    trace_call("AdditiveExpr");
    try {
 Expr expr;
 AdditiveExpr superexpr = new AdditiveExpr();
 int operator = Expr.NOP_OP;
      expr = MultiplicativeExpr();
 Expr operand=expr;
 superexpr.addExpr(operand, operator);
      label_12:
      while (true) {
        switch (jj_nt.kind) {
        case PLUS:
        case MINUS:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_12;
        }
        switch (jj_nt.kind) {
        case PLUS:
          jj_consume_token(PLUS);
 operator=Expr.ADD_OP;
          break;
        case MINUS:
          jj_consume_token(MINUS);
 operator=Expr.SUB_OP;
          break;
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        operand = MultiplicativeExpr();
 superexpr.addExpr(operand, operator);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AdditiveExpr");
    }
  }

/* [26] MultiplicativeExpr ::= UnaryExpr | MultiplicativeExpr MultiplyOperator UnaryExpr
			| MultiplicativeExpr 'div' UnaryExpr | MultiplicativeExpr 'mod' UnaryExpr  */
  final public Expr MultiplicativeExpr() throws ParseException {
    trace_call("MultiplicativeExpr");
    try {
 Expr expr;
 MultiplicativeExpr superexpr = new MultiplicativeExpr();
 int operator = Expr.NOP_OP;
      /*		UnaryExpr() ( ( <MultiplyOperator> | "div" | "mod" ) UnaryExpr() )* */
      expr = UnaryExpr();
 Expr operand=expr;
 superexpr.addExpr(operand, operator);
      label_13:
      while (true) {
        switch (jj_nt.kind) {
        case MOD:
        case DIV:
        case 44:
          ;
          break;
        default:
          jj_la1[38] = jj_gen;
          break label_13;
        }
        switch (jj_nt.kind) {
        case 44:
          jj_consume_token(44);
 operator=Expr.MUL_OP;
          break;
        case DIV:
          jj_consume_token(DIV);
 operator=Expr.DIV_OP;
          break;
        case MOD:
          jj_consume_token(MOD);
 operator=Expr.MOD_OP;
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        operand = UnaryExpr();
 superexpr.addExpr(operand, operator);
      }
 if (superexpr.getExprsCount()>1) {if (true) return superexpr;}
else {if (true) return expr;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MultiplicativeExpr");
    }
  }

/* [27]    UnaryExpr    ::=    UnionExpr  | '-' UnaryExpr  */
  final public Expr UnaryExpr() throws ParseException {
    trace_call("UnaryExpr");
    try {
 Expr expr;
      switch (jj_nt.kind) {
      case SLASH:
      case SLASHSLASH:
      case VARIABLE:
      case Literal:
      case Number:
      case ID:
      case OR:
      case AND:
      case MOD:
      case DIV:
      case KEY:
      case NODE:
      case TEXT:
      case COMMENT:
      case PI:
      case AxisName:
      case NCName:
      case 36:
      case 39:
      case 40:
      case 41:
      case 44:
        expr = UnionExpr();
 {if (true) return expr;}
        break;
      case MINUS:
        jj_consume_token(MINUS);
        expr = UnaryExpr();
 expr.setPositive(expr.getNegative());
{if (true) return expr;}
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnaryExpr");
    }
  }

/*-------------*/
/* 3.6 Strings */
/*-------------*/

/*----------------------------------*/
/* 3.7 Expression Lexical Structure */
/*----------------------------------*/
/*
The following special tokenization rules must be applied in the order
specified to disambiguate the grammar:

1. If there is a preceding token and the preceding token is not one of
   @, ::, (, [, , or an Operator,
   then a * must be recognized as a MultiplyOperator and an NCName must
   be recognized as an OperatorName.

2. If the character following an NCName (possibly after intervening ExprWhitespace)
   is (, then the token must be recognized as a NodeType or a FunctionName.

3. If the two characters following an NCName (possibly after intervening ExprWhitespace)
   are ::, then the token must be recognized as an AxisName.

4. Otherwise, the token must not be recognized as a MultiplyOperator, an OperatorName,
   a NodeType, a FunctionName, or an AxisName.
*/

/*
[28]    ExprToken    ::=    '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'  
   | WildcardName  | NodeType  | Operator  | FunctionName  | AxisName  | Literal  
   | Number  | VariableReference  
*/
/* [34]    MultiplyOperator    ::=    '*'  */

/* [35]    FunctionName    ::=    QName - NodeType   */
  final public String FunctionName() throws ParseException {
    trace_call("FunctionName");
    try {
 String name;
      name = QName_Without_NodeType();
 {if (true) return name;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionName");
    }
  }

/* [36]    VariableReference    ::=    '$' QName  */
  final public Expr VariableReference() throws ParseException {
    trace_call("VariableReference");
    try {
 Expr expr;
String name;
      jj_consume_token(VARIABLE);
      name = QName();
 {if (true) return new Variable(name);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("VariableReference");
    }
  }

/* [37]    WildcardName    ::=    '*'     | NCName ':' '*'     | QName  */
  final public NameTest NameTest() throws ParseException {
    trace_call("NameTest");
    try {
 String prefix;
String name;
      switch (jj_nt.kind) {
      case 44:
        jj_consume_token(44);
 {if (true) return new NameTest("*");}
        break;
      default:
        jj_la1[41] = jj_gen;
        if (jj_2_7(2147483647)) {
          prefix = NCName();
          jj_consume_token(35);
          jj_consume_token(44);
 {if (true) return new NameTest(prefix, "*");}
        } else {
          switch (jj_nt.kind) {
          case ID:
          case OR:
          case AND:
          case MOD:
          case DIV:
          case KEY:
          case NODE:
          case TEXT:
          case COMMENT:
          case PI:
          case NCName:
            name = QName();
 {if (true) return NameTest.parseQName(name);}
            break;
          default:
            jj_la1[42] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NameTest");
    }
  }

/* [38]    NodeType    ::=    'comment' | 'text'  | 'processing-instruction'  | 'node'  */
  final public NodeType NodeType() throws ParseException {
    trace_call("NodeType");
    try {
      switch (jj_nt.kind) {
      case TEXT:
        jj_consume_token(TEXT);
        {if (true) return new NodeType("text");}
        break;
      case NODE:
        jj_consume_token(NODE);
        {if (true) return  new NodeType("node");}
        break;
      case COMMENT:
        jj_consume_token(COMMENT);
        {if (true) return new NodeType("comment");}
        break;
      case PI:
        jj_consume_token(PI);
        {if (true) return new NodeType("processing-instruction");}
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NodeType");
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  final private boolean jj_3R_113() {
    if (jj_3R_114()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_115()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_61()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(DIV)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(44)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(35)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_80()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_105() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_80()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(40)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_105()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(39)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(41)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(38)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_75()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_75()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_76()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(AxisName)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(KEY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(35)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(DIV)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(SLASHSLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_62()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(Number)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(Literal)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(SLASHSLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_61()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(NCName)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_80() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_98()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_98()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_99()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_59()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(PI)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(COMMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(TEXT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(NODE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_3R_24()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(GTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(KEY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(LTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(DIV)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(GT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(LT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_94()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(NCName)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_94()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_95()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(PI)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(COMMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(NODE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(NEQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(TEXT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(EQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_85()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(35)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(44)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_85()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_86()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(SLASHSLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_3R_64()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(35)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(44)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(44)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(VARIABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_64()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_79()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(SLASHSLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(SLASHSLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_72()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(42)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_61()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(43)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_72()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_73()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_74()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(PI)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(Literal)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_18()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_scan_token(KEY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(Literal)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(38)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(Literal)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(Literal)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_77()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(PI)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(Literal)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_18()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_31()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_113()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(UNION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_114()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public XPathParserTokenManager token_source;
  ASCII_UCodeESC_CharStream jj_input_stream;
  public Token token, jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[44];
  final private int[] jj_la1_0 = {0xff800000,0x1f800000,0x0,0x0,0x10,0xff800000,0xc,0xc,0x8,0xff800008,0xff80000c,0x10800000,0xc,0xc,0x0,0xff80000c,0xc,0xff800000,0x0,0xff800000,0xff800000,0x0,0x1f816000,0x0,0xff81604c,0x10,0xc,0xc,0xff80000c,0x0,0x1000000,0x2000000,0x180,0x180,0x1e00,0x1e00,0x60,0x60,0xc000000,0xc000000,0xff81604c,0x0,0xff800000,0xe0000000,};
  final private int[] jj_la1_1 = {0x5,0x4,0x8,0x8,0x0,0x1085,0x0,0x0,0x0,0x1085,0x1085,0x0,0x0,0x0,0x400,0x1387,0x0,0x1087,0x400,0x1387,0x1005,0x80,0x14,0x40,0x1397,0x0,0x0,0x0,0x1387,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x1397,0x1000,0x5,0x1,};
  final private JJCalls[] jj_2_rtns = new JJCalls[7];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public XPathParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
    token_source = new XPathParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void e1(){};
  
  public XPathParser(java.io.Reader stream) throws IOException {
    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
  }
  
  public void temp() throws IOException {
	    token_source = new XPathParserTokenManager(jj_input_stream);
	    token = new Token();
	    
		char first = jj_input_stream.readChar(); // make the value symbolic in this function!
		jj_input_stream.backup(1);   
	    if (first == 'a') {
	    	e1();
	    }
//	    System.out.println(first);   
	    
	    token.next = jj_nt = token_source.getNextToken(); // can generate constraints!
	    
	    jj_gen = 0;
	    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
	    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public XPathParser(XPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(XPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum1 = jj_expentries.elements(); enum1.hasMoreElements();) {
        int[] oldentry = (int[])(enum1.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[45];
    for (int i = 0; i < 45; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 44; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 45; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

  final public void enable_tracing() {
    trace_enabled = true;
  }

  final public void disable_tracing() {
    trace_enabled = false;
  }

  final private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  final private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  final private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(">" + where);
    }
  }

  final private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 7; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
